python3 ./src/trace_hoffman_method.py

================ С Т И С Н Е Н Н Я ================
Завантажуємо файл: assets/sample1_short.txt
Довжина вхідного тексту: 11 символів

=== КРОК 1: Формування таблиці частот ===
Символ 'a' → частота 5
Символ 'b' → частота 2
Символ 'r' → частота 2
Символ 'c' → частота 1
Символ 'd' → частота 1

=== КРОК 2: Побудова мін-купи ===
Додаємо вузол: 'a' з частотою 5
Додаємо вузол: 'b' з частотою 2
Додаємо вузол: 'r' з частотою 2
Додаємо вузол: 'c' з частотою 1
Додаємо вузол: 'd' з частотою 1
Початковий heap: [Node('c', 1), Node('d', 1), Node('r', 2), Node('a', 5), Node('b', 2)]

=== КРОК 3: Побудова дерева Хаффмана ===
Витягуємо 2 мінімальних вузли: Node('c', 1) та Node('d', 1)
Створюємо новий вузол частотою 2
Поточний heap: [Node('r', 2), Node('b', 2), Node('a', 5), Node(None, 2)]
Витягуємо 2 мінімальних вузли: Node('r', 2) та Node('b', 2)
Створюємо новий вузол частотою 4
Поточний heap: [Node(None, 2), Node('a', 5), Node(None, 4)]
Витягуємо 2 мінімальних вузли: Node(None, 2) та Node(None, 4)
Створюємо новий вузол частотою 6
Поточний heap: [Node('a', 5), Node(None, 6)]
Витягуємо 2 мінімальних вузли: Node('a', 5) та Node(None, 6)
Створюємо новий вузол частотою 11
Поточний heap: [Node(None, 11)]

Дерево Хаффмана побудовано ✔

=== КРОК 4: Генерація кодів Хаффмана ===
Код для 'a' = 0
Код для 'c' = 100
Код для 'd' = 101
Код для 'r' = 110
Код для 'b' = 111

=== КРОК 5: Кодування тексту ===
Бітовий потік: 01111100100010101111100

Додаємо 1 біт(ів) доповнення для вирівнювання до байта.

=== КРОК 6: Запис стисненого файлу ===
Файл успішно стиснено → output/sample1_short.huff
